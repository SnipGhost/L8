# Лабораторная работа №8 #

## Постановка задачи ##

Написать программу, проводящую шифрование файла и вывод статистики.

Производить шифрование файла по следующему алгоритму:

- Сформировать массив ключей из файла-ключа для каждого слова определив его сумму кодов 
символов деленную по модулю (%) на 256. Так слову `abc` соответсвует ключ `38`: а слову `ab` ключ `195`.
- Для кажого символа в файле-источнике (который надо зашифровать) проводим операцию побитового 
исключаещего или (XOR) c соответвующим ключом из массива. Так, если в файле-ключе было три слова (т.е. имеем
массив ключей из 3-х элементов), то первому символу источника соответсвует первый ключ, второму - второй, 
третьему - третий, четвертому снова первый и так далее. Можно сказать, что i-му элементу соответсвует 
[i % len]-ый элемент массива ключей: где len - размер массива ключей.

Программу оформить как циклический вызов меню вида:

```
=-----------= Шифрование файлов =-----------=
1) Сформировать массив ключей
2) Зашифровать/Расшифровать файл
3) Вывести статистику для заданного символа
4) Выход
=-------------------------------------------=
```

### Пункт 1 ###

Сформировать и вывести на экран массив ключей для указанного файла по заданному алгоритму.

Реализовать генерацию ключей в виде отдельной функции.

### Пункт 2 ###

Если есть сформированный массив ключей, то провести шифрование/дешифровку указанного файла. 

Иначе вывести сообщение об ошибке.

### Пункт 3 ###

Для указанного символа сформировать и вывести таблицу вида:

```
 | 0 1 2 3 4 5 6 7 8 9 A B C D E F |
-|---------------------------------|
0|.................................|
1|.......2.........................|
2|.................................|
3|.............................1...|
4|.................................|
5|.................................|
6|.................................|
7|.................................|
8|.................................|
9|.................................|
A|.................................|
B|.................................|
C|.................................|
D|.............1...................|
E|.................................|
F|.................................|
-|---------------------------------|
```

Где указывается сколькми различными символами был зашифрован исходный символ источника.
Причем указывается не сам символ, а только его код. Так, для заданного примера некий символ
встретился всего 4 раза и дважды был зашифрован символом с кодом 31, и по разу символами с кодами
E3 и 6D.

### Пункт 4 ###

Очистить память и завершить работу программы.

## Реализация структуры для генерации и хранения ключей ##

```cpp
struct TKEYS {
	int *key;                // Сам массив ключей
	unsigned size;           // Размер массива
	TKEYS(istream &input);   // Конструктор-генератор, принимает на вход поток ввода
	~TKEYS();                // Деструктор, обеспечивает надежную очистку памяти
	void print();            // Метод печати массива
};
```

## Реализация генерации ключей на основе strtok ##

```cpp
	
	// input - поток ввода (файл или терминал)
	
	const int len = 256; // Максимальная длина строки
	char str[len];       // Задаем переменную для хранения считанной строки
	char *token;         // Токен, в котором храним текущее слово строки

	char delims[] = " .,!?/\\{}[]<>()'\":;|_#@*";  
	// Разделители по которым режем строку

	while (input.getline(str, len))        // Построчно читаем файл
	{
		token = strtok(str, delims);   // Вычленяем первое слово
		//cout << token << endl;       // Выведет слово (для отладки)
		while (token != NULL)          // Пока в строке останется хоть что-то
		{
			// Считаем ключ для данного слова
			// Слово хранится (полностью) в token
			// ...
			token = strtok(NULL, delims); // Вычленяем следующее слово
			// Здесь пишем NULL, так как уже передали ей строку в первый раз
		}
	}
```

## Конец ##

Авторы: Михаил Кучеренко & Роман Байбарин

МГТУ им. Н.Э.Баумана, группа ИУ5-14