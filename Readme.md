# Лабораторная работа №8 #

## Постановка задачи ##

Написать программу, проводящую шифрование файла и вывод статистики.

Производить шифрование файла по следующему алгоритму:

- Сформировать массив ключей из файла-ключа для каждого слова определив его сумму кодов символов деленную по модулю (%) на 256. Так слову **abc** соответсвует ключ **38**: а слову **ab** ключ **195**. На практике русским символам в соответсвие ставятся отрицательные коды, поэтому необходимо производить явное приведение к unsigned char.
- Для кажого символа в файле-источнике (который надо зашифровать) проводим операцию побитового исключаещего или (XOR) c соответвующим ключом из массива. Так, если в файле-ключе было три слова (т.е. имеем массив ключей из 3-х элементов), то первому символу источника соответсвует первый ключ, второму - второй, третьему - третий, четвертому снова первый и так далее. Можно сказать, что **i-му** элементу соответсвует **[i % len]-ый** элемент массива ключей: где **len** - размер массива ключей.

Программу оформить как циклический вызов меню вида:

```
=-----------= Шифрование файлов =-----------=
1) Сформировать массив ключей
2) Вывести массив ключей
3) Зашифровать/Расшифровать файл
4) Вывести статистику для заданного символа
5) Тестирование
6) Выход
=-------------------------------------------=
```

#### Пункт 1 ####

Сформировать массив ключей для указанного файла по заданному алгоритму.  
Реализовать генерацию ключей в виде отдельной функции.

#### Пункт 2 ####

Вывести, в адекватном виде, с разделением по блокам (как в лабе 7), массив сгенерированных ключей, если ключи были сгенерированы. Иначе вывести сообщение об ошибке.

#### Пункт 3 ####

Если есть сформированный массив ключей, то провести шифрование/дешифровку указанного файла.  
Иначе вывести сообщение об ошибке.

#### Пункт 4 ####

Для указанного символа сформировать и вывести таблицу вида:

```
 | 0 1 2 3 4 5 6 7 8 9 A B C D E F |
-|---------------------------------|
0|.................................|
1|.......2.........................|
2|.................................|
3|.............................1...|
4|.................................|
5|.................................|
6|.................................|
7|.................................|
8|.................................|
9|.................................|
A|.................................|
B|.................................|
C|.................................|
D|.............1...................|
E|.................................|
F|.................................|
-|---------------------------------|
```

Где указывается сколькми различными символами был зашифрован исходный символ источника.
Причем указывается не сам символ, а только его код. Так, для заданного примера некий символ
встретился всего 4 раза и дважды был зашифрован символом с кодом 0x13, и по разу символами с кодами
0x3E и 0xD6.

### Пункт 5 ###

-???-

### Пункт 6 ###

Очистить память и завершить работу программы. 

---

## Cтруктура для генерации и хранения ключей ##
```cpp
struct TKEYS {
	int *key;                // Сам массив ключей
	unsigned size;           // Размер массива
	TKEYS(istream &input);   // Конструктор-генератор, принимает на вход поток ввода
	~TKEYS();                // Деструктор, обеспечивает надежную очистку памяти
	void print();            // Метод печати массива
};
```

## Реализация генерации ключей на основе strtok_s ##
```cpp
	// input - поток ввода (файл или терминал)
	
	const int len = 256; // Максимальная длина строки
	char str[len];       // Задаем переменную для хранения считанной строки
	char *token;         // Токен, в котором храним текущее слово строки
	char *nex_token;     // Вспомогательный токен-контекст
    
	char delims[] = " .,!?/\\{}[]<>()'\":;|_#@*";  
	// Разделители по которым режем строку

	while (input.getline(str, len))        // Построчно читаем файл
	{
		token = strtok_s(str, delims, &next_token); // Вычленяем первое слово
		//cout << token << endl;                    // Выведет слово (для отладки)
		while (token != NULL)                       // Пока в строке останется хоть что-то
		{
			// Слово хранится (полностью) в token
			// ... (в цикле проходимся по всему слову и находим ключ) ...
			token = strtok_s(NULL, delims, &next_token); // Вычленяем следующее слово
			// Здесь пишем NULL, так как уже передали ей строку в первый раз
            // Увеличиваем счетчик ключей, переходим на следующее слово
		}
	}
```

## Получение текущей директории ##
```cpp
	#include <direct.h>
    // ...
    
	// НЕ РАБОТАЕТ ДЛЯ РЕЖИМА ОТЛАДКИ, ТОЛЬКО ЕСЛИ ЗАПУСКАТЬ ФАЙЛ САМОСТОЯТЕЛЬНО
	char curdir[1024];                // Временные переменные
	_getcwd(curdir, sizeof(curdir));  // Получаем текущую директорию
	string path = curdir;             // Копируем в наш путь
	path += "\\Data\\";               // Добавляем имя директории
```

## Работа с указателем на ключи и файлом ##
```cpp
    // Где-то в начале функции main
	TKEYS *keys = NULL;                  // Задаем указатель на структуру с ключами
    //...
    
    // Внутри блока меню, формирующего ключи
    if (keys != NULL) delete keys;       // Если вдруг там что-то есть, то удаляем это
    
    string in;
	cout << "Введите имя файла: ";       // Читаем имя файла
	cin >> in;                           
	ifstream fkey;                       // Задаем поток ввода из файла
	fkey.open(path + in);                // Открываем файл по адресу path/in
    
	if (fkey.fail()) {                   // Если зафейлились, значит открыть не удалось
		cout << "Ошибка чтения файла\n"; 
	} else {                             // Иначе - открыть удалось и все ОК
		keys = new TKEYS(fkey);          // Передаем конструктору поток, для генерации ключей
		fkey.close();                    // Закрываем файл
	}
```

## Аналоговая работа с файлами, через указатели ##
```cpp
	int len, pos = 0; // Длина файла (напомню, файл бинарный) и текущая позиция
	FILE *fs, *fr;    // Указатели на файл ресурса
	errno_t err;
	err = fopen_s(&fs, inputfile.c_str(), "rb"); // Открываем на чтение (входной файл)
	if (err != 0) {                              // Если открыть не удалось
    	cout << "Ошибка чтения файла\n"; 
        return -1;                               // Завершаем работу блока
    }
	fopen_s(&fr, outputfile.c_str(), "wb"); // Открываем на запись (выходной файл)
    
	fseek(fs, 0, SEEK_END);  // Устанавливаем курсор в конец файла
	len = ftell(fs);         // Записываем позицию конца файла (это его длина)
	rewind(fs);              // Вернемся в начало файла
    
    unsigned char c1, c2;             // Буферные переменные для считывания
	fread(&c1, sizeof(char), 1, fs);  // Читаем один символ из файла
	while (pos < len)                 // Пока мы не достигнем конца файла
	{
		pos++;                        // Двигаем текущую позицию
        
		c2 = c1 ^ (keys->key[pos % keys->size]); // Шифруем символ
		fwrite(&c2, sizeof(char), 1, fr);        // Записываем его в выходной файл
		fread(&c1, sizeof(char), 1, fs);         // Читаем следующий символ
	}
    
    fclose(fs); // Закрываем оба файла
	fclose(fr); // ОБА!
```

## Конец ##

**Авторы: Михаил Кучеренко и Роман Байбарин**

МГТУ им. Н.Э.Баумана, группа ИУ5-14, 2016 год.